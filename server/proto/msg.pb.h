// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_msg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_msg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msg_2eproto;
namespace msg {
class FriendCtrl;
struct FriendCtrlDefaultTypeInternal;
extern FriendCtrlDefaultTypeInternal _FriendCtrl_default_instance_;
class FriendMsg;
struct FriendMsgDefaultTypeInternal;
extern FriendMsgDefaultTypeInternal _FriendMsg_default_instance_;
class FriendState;
struct FriendStateDefaultTypeInternal;
extern FriendStateDefaultTypeInternal _FriendState_default_instance_;
class GroupCtrl;
struct GroupCtrlDefaultTypeInternal;
extern GroupCtrlDefaultTypeInternal _GroupCtrl_default_instance_;
class GroupMsg;
struct GroupMsgDefaultTypeInternal;
extern GroupMsgDefaultTypeInternal _GroupMsg_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class MqMessage;
struct MqMessageDefaultTypeInternal;
extern MqMessageDefaultTypeInternal _MqMessage_default_instance_;
class ProtoReq;
struct ProtoReqDefaultTypeInternal;
extern ProtoReqDefaultTypeInternal _ProtoReq_default_instance_;
class ProtoResp;
struct ProtoRespDefaultTypeInternal;
extern ProtoRespDefaultTypeInternal _ProtoResp_default_instance_;
class Pull;
struct PullDefaultTypeInternal;
extern PullDefaultTypeInternal _Pull_default_instance_;
class PushReq;
struct PushReqDefaultTypeInternal;
extern PushReqDefaultTypeInternal _PushReq_default_instance_;
class PushResp;
struct PushRespDefaultTypeInternal;
extern PushRespDefaultTypeInternal _PushResp_default_instance_;
class SystemNotify;
struct SystemNotifyDefaultTypeInternal;
extern SystemNotifyDefaultTypeInternal _SystemNotify_default_instance_;
}  // namespace msg
PROTOBUF_NAMESPACE_OPEN
template<> ::msg::FriendCtrl* Arena::CreateMaybeMessage<::msg::FriendCtrl>(Arena*);
template<> ::msg::FriendMsg* Arena::CreateMaybeMessage<::msg::FriendMsg>(Arena*);
template<> ::msg::FriendState* Arena::CreateMaybeMessage<::msg::FriendState>(Arena*);
template<> ::msg::GroupCtrl* Arena::CreateMaybeMessage<::msg::GroupCtrl>(Arena*);
template<> ::msg::GroupMsg* Arena::CreateMaybeMessage<::msg::GroupMsg>(Arena*);
template<> ::msg::Log* Arena::CreateMaybeMessage<::msg::Log>(Arena*);
template<> ::msg::MqMessage* Arena::CreateMaybeMessage<::msg::MqMessage>(Arena*);
template<> ::msg::ProtoReq* Arena::CreateMaybeMessage<::msg::ProtoReq>(Arena*);
template<> ::msg::ProtoResp* Arena::CreateMaybeMessage<::msg::ProtoResp>(Arena*);
template<> ::msg::Pull* Arena::CreateMaybeMessage<::msg::Pull>(Arena*);
template<> ::msg::PushReq* Arena::CreateMaybeMessage<::msg::PushReq>(Arena*);
template<> ::msg::PushResp* Arena::CreateMaybeMessage<::msg::PushResp>(Arena*);
template<> ::msg::SystemNotify* Arena::CreateMaybeMessage<::msg::SystemNotify>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace msg {

enum FriendCtrl_Type : int {
  FriendCtrl_Type_FRIEND_REQ = 0,
  FriendCtrl_Type_FRIEND_DEL = 1,
  FriendCtrl_Type_FRIEND_AUTH_OK = 2,
  FriendCtrl_Type_FRIEND_AUTH_REJECT = 3,
  FriendCtrl_Type_FriendCtrl_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FriendCtrl_Type_FriendCtrl_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FriendCtrl_Type_IsValid(int value);
constexpr FriendCtrl_Type FriendCtrl_Type_Type_MIN = FriendCtrl_Type_FRIEND_REQ;
constexpr FriendCtrl_Type FriendCtrl_Type_Type_MAX = FriendCtrl_Type_FRIEND_AUTH_REJECT;
constexpr int FriendCtrl_Type_Type_ARRAYSIZE = FriendCtrl_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FriendCtrl_Type_descriptor();
template<typename T>
inline const std::string& FriendCtrl_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FriendCtrl_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FriendCtrl_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FriendCtrl_Type_descriptor(), enum_t_value);
}
inline bool FriendCtrl_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FriendCtrl_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FriendCtrl_Type>(
    FriendCtrl_Type_descriptor(), name, value);
}
enum FriendState_Type : int {
  FriendState_Type_INPUTING = 0,
  FriendState_Type_ONLINE = 1,
  FriendState_Type_OFFLINE = 2,
  FriendState_Type_FriendState_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FriendState_Type_FriendState_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FriendState_Type_IsValid(int value);
constexpr FriendState_Type FriendState_Type_Type_MIN = FriendState_Type_INPUTING;
constexpr FriendState_Type FriendState_Type_Type_MAX = FriendState_Type_OFFLINE;
constexpr int FriendState_Type_Type_ARRAYSIZE = FriendState_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FriendState_Type_descriptor();
template<typename T>
inline const std::string& FriendState_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FriendState_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FriendState_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FriendState_Type_descriptor(), enum_t_value);
}
inline bool FriendState_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FriendState_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FriendState_Type>(
    FriendState_Type_descriptor(), name, value);
}
enum FriendMsg_Type : int {
  FriendMsg_Type_CANCEL = 0,
  FriendMsg_Type_TEXT = 1,
  FriendMsg_Type_PICTURE = 2,
  FriendMsg_Type_VIDEO = 3,
  FriendMsg_Type_FILE = 4,
  FriendMsg_Type_CACELED = 5,
  FriendMsg_Type_FriendMsg_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FriendMsg_Type_FriendMsg_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FriendMsg_Type_IsValid(int value);
constexpr FriendMsg_Type FriendMsg_Type_Type_MIN = FriendMsg_Type_CANCEL;
constexpr FriendMsg_Type FriendMsg_Type_Type_MAX = FriendMsg_Type_CACELED;
constexpr int FriendMsg_Type_Type_ARRAYSIZE = FriendMsg_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FriendMsg_Type_descriptor();
template<typename T>
inline const std::string& FriendMsg_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FriendMsg_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FriendMsg_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FriendMsg_Type_descriptor(), enum_t_value);
}
inline bool FriendMsg_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FriendMsg_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FriendMsg_Type>(
    FriendMsg_Type_descriptor(), name, value);
}
enum SystemNotify_Type : int {
  SystemNotify_Type_USER = 0,
  SystemNotify_Type_FRIEND = 1,
  SystemNotify_Type_GROUP = 2,
  SystemNotify_Type_SystemNotify_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SystemNotify_Type_SystemNotify_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SystemNotify_Type_IsValid(int value);
constexpr SystemNotify_Type SystemNotify_Type_Type_MIN = SystemNotify_Type_USER;
constexpr SystemNotify_Type SystemNotify_Type_Type_MAX = SystemNotify_Type_GROUP;
constexpr int SystemNotify_Type_Type_ARRAYSIZE = SystemNotify_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SystemNotify_Type_descriptor();
template<typename T>
inline const std::string& SystemNotify_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemNotify_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemNotify_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SystemNotify_Type_descriptor(), enum_t_value);
}
inline bool SystemNotify_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemNotify_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SystemNotify_Type>(
    SystemNotify_Type_descriptor(), name, value);
}
enum GroupCtrl_Type : int {
  GroupCtrl_Type_GROUP_CREATE = 0,
  GroupCtrl_Type_GROUP_DELETE = 1,
  GroupCtrl_Type_GROUP_ADD_MEMBER = 2,
  GroupCtrl_Type_GROUP_ENTER = 3,
  GroupCtrl_Type_GROUP_EXIT = 4,
  GroupCtrl_Type_GROUP_AUTH_OK = 5,
  GroupCtrl_Type_GROUP_AUTH_REJECT = 6,
  GroupCtrl_Type_GroupCtrl_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GroupCtrl_Type_GroupCtrl_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GroupCtrl_Type_IsValid(int value);
constexpr GroupCtrl_Type GroupCtrl_Type_Type_MIN = GroupCtrl_Type_GROUP_CREATE;
constexpr GroupCtrl_Type GroupCtrl_Type_Type_MAX = GroupCtrl_Type_GROUP_AUTH_REJECT;
constexpr int GroupCtrl_Type_Type_ARRAYSIZE = GroupCtrl_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroupCtrl_Type_descriptor();
template<typename T>
inline const std::string& GroupCtrl_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupCtrl_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupCtrl_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GroupCtrl_Type_descriptor(), enum_t_value);
}
inline bool GroupCtrl_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupCtrl_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GroupCtrl_Type>(
    GroupCtrl_Type_descriptor(), name, value);
}
enum GroupMsg_Type : int {
  GroupMsg_Type_CANCEL = 0,
  GroupMsg_Type_TEXT = 1,
  GroupMsg_Type_PICTURE = 2,
  GroupMsg_Type_VIDEO = 3,
  GroupMsg_Type_FILE = 4,
  GroupMsg_Type_CACELED = 5,
  GroupMsg_Type_GroupMsg_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GroupMsg_Type_GroupMsg_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GroupMsg_Type_IsValid(int value);
constexpr GroupMsg_Type GroupMsg_Type_Type_MIN = GroupMsg_Type_CANCEL;
constexpr GroupMsg_Type GroupMsg_Type_Type_MAX = GroupMsg_Type_CACELED;
constexpr int GroupMsg_Type_Type_ARRAYSIZE = GroupMsg_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroupMsg_Type_descriptor();
template<typename T>
inline const std::string& GroupMsg_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupMsg_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupMsg_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GroupMsg_Type_descriptor(), enum_t_value);
}
inline bool GroupMsg_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupMsg_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GroupMsg_Type>(
    GroupMsg_Type_descriptor(), name, value);
}
enum Pull_Type : int {
  Pull_Type_PULL_OFFLINE = 0,
  Pull_Type_PULL_HISTORY = 1,
  Pull_Type_Pull_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Pull_Type_Pull_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Pull_Type_IsValid(int value);
constexpr Pull_Type Pull_Type_Type_MIN = Pull_Type_PULL_OFFLINE;
constexpr Pull_Type Pull_Type_Type_MAX = Pull_Type_PULL_HISTORY;
constexpr int Pull_Type_Type_ARRAYSIZE = Pull_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Pull_Type_descriptor();
template<typename T>
inline const std::string& Pull_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Pull_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Pull_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Pull_Type_descriptor(), enum_t_value);
}
inline bool Pull_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Pull_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Pull_Type>(
    Pull_Type_descriptor(), name, value);
}
enum Log_Type : int {
  Log_Type_LOGIN = 0,
  Log_Type_LOGOUT = 1,
  Log_Type_KICKOUT = 2,
  Log_Type_Log_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Log_Type_Log_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Log_Type_IsValid(int value);
constexpr Log_Type Log_Type_Type_MIN = Log_Type_LOGIN;
constexpr Log_Type Log_Type_Type_MAX = Log_Type_KICKOUT;
constexpr int Log_Type_Type_ARRAYSIZE = Log_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Log_Type_descriptor();
template<typename T>
inline const std::string& Log_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Log_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Log_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Log_Type_descriptor(), enum_t_value);
}
inline bool Log_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Log_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Log_Type>(
    Log_Type_descriptor(), name, value);
}
enum ProtoReq_Version : int {
  ProtoReq_Version_VERSION_0 = 0,
  ProtoReq_Version_ProtoReq_Version_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProtoReq_Version_ProtoReq_Version_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProtoReq_Version_IsValid(int value);
constexpr ProtoReq_Version ProtoReq_Version_Version_MIN = ProtoReq_Version_VERSION_0;
constexpr ProtoReq_Version ProtoReq_Version_Version_MAX = ProtoReq_Version_VERSION_0;
constexpr int ProtoReq_Version_Version_ARRAYSIZE = ProtoReq_Version_Version_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProtoReq_Version_descriptor();
template<typename T>
inline const std::string& ProtoReq_Version_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProtoReq_Version>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProtoReq_Version_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProtoReq_Version_descriptor(), enum_t_value);
}
inline bool ProtoReq_Version_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProtoReq_Version* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProtoReq_Version>(
    ProtoReq_Version_descriptor(), name, value);
}
enum ProtoReqType : int {
  TypeEmpty = 0,
  TypeFriendCtrl = 1,
  TypeFriendState = 2,
  TypeFriendMsg = 3,
  TypeSystemNotify = 4,
  TypeGroupCtrl = 5,
  TypeGroupMsg = 6,
  TypePull = 7,
  TypeLog = 8,
  ProtoReqType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProtoReqType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProtoReqType_IsValid(int value);
constexpr ProtoReqType ProtoReqType_MIN = TypeEmpty;
constexpr ProtoReqType ProtoReqType_MAX = TypeLog;
constexpr int ProtoReqType_ARRAYSIZE = ProtoReqType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProtoReqType_descriptor();
template<typename T>
inline const std::string& ProtoReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProtoReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProtoReqType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProtoReqType_descriptor(), enum_t_value);
}
inline bool ProtoReqType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProtoReqType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProtoReqType>(
    ProtoReqType_descriptor(), name, value);
}
// ===================================================================

class FriendCtrl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.FriendCtrl) */ {
 public:
  inline FriendCtrl() : FriendCtrl(nullptr) {}
  ~FriendCtrl() override;
  explicit PROTOBUF_CONSTEXPR FriendCtrl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendCtrl(const FriendCtrl& from);
  FriendCtrl(FriendCtrl&& from) noexcept
    : FriendCtrl() {
    *this = ::std::move(from);
  }

  inline FriendCtrl& operator=(const FriendCtrl& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendCtrl& operator=(FriendCtrl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendCtrl& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendCtrl* internal_default_instance() {
    return reinterpret_cast<const FriendCtrl*>(
               &_FriendCtrl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FriendCtrl& a, FriendCtrl& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendCtrl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendCtrl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendCtrl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendCtrl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendCtrl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendCtrl& from) {
    FriendCtrl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendCtrl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.FriendCtrl";
  }
  protected:
  explicit FriendCtrl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FriendCtrl_Type Type;
  static constexpr Type FRIEND_REQ =
    FriendCtrl_Type_FRIEND_REQ;
  static constexpr Type FRIEND_DEL =
    FriendCtrl_Type_FRIEND_DEL;
  static constexpr Type FRIEND_AUTH_OK =
    FriendCtrl_Type_FRIEND_AUTH_OK;
  static constexpr Type FRIEND_AUTH_REJECT =
    FriendCtrl_Type_FRIEND_AUTH_REJECT;
  static inline bool Type_IsValid(int value) {
    return FriendCtrl_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    FriendCtrl_Type_Type_MIN;
  static constexpr Type Type_MAX =
    FriendCtrl_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    FriendCtrl_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return FriendCtrl_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return FriendCtrl_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return FriendCtrl_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.FriendCtrl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class FriendState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.FriendState) */ {
 public:
  inline FriendState() : FriendState(nullptr) {}
  ~FriendState() override;
  explicit PROTOBUF_CONSTEXPR FriendState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendState(const FriendState& from);
  FriendState(FriendState&& from) noexcept
    : FriendState() {
    *this = ::std::move(from);
  }

  inline FriendState& operator=(const FriendState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendState& operator=(FriendState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendState& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendState* internal_default_instance() {
    return reinterpret_cast<const FriendState*>(
               &_FriendState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FriendState& a, FriendState& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendState& from) {
    FriendState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.FriendState";
  }
  protected:
  explicit FriendState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FriendState_Type Type;
  static constexpr Type INPUTING =
    FriendState_Type_INPUTING;
  static constexpr Type ONLINE =
    FriendState_Type_ONLINE;
  static constexpr Type OFFLINE =
    FriendState_Type_OFFLINE;
  static inline bool Type_IsValid(int value) {
    return FriendState_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    FriendState_Type_Type_MIN;
  static constexpr Type Type_MAX =
    FriendState_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    FriendState_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return FriendState_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return FriendState_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return FriendState_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kStatesFieldNumber = 2,
  };
  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // int32 states = 2;
  void clear_states();
  int32_t states() const;
  void set_states(int32_t value);
  private:
  int32_t _internal_states() const;
  void _internal_set_states(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.FriendState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t type_;
    int32_t states_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class FriendMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.FriendMsg) */ {
 public:
  inline FriendMsg() : FriendMsg(nullptr) {}
  ~FriendMsg() override;
  explicit PROTOBUF_CONSTEXPR FriendMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendMsg(const FriendMsg& from);
  FriendMsg(FriendMsg&& from) noexcept
    : FriendMsg() {
    *this = ::std::move(from);
  }

  inline FriendMsg& operator=(const FriendMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendMsg& operator=(FriendMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendMsg* internal_default_instance() {
    return reinterpret_cast<const FriendMsg*>(
               &_FriendMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FriendMsg& a, FriendMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendMsg& from) {
    FriendMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.FriendMsg";
  }
  protected:
  explicit FriendMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FriendMsg_Type Type;
  static constexpr Type CANCEL =
    FriendMsg_Type_CANCEL;
  static constexpr Type TEXT =
    FriendMsg_Type_TEXT;
  static constexpr Type PICTURE =
    FriendMsg_Type_PICTURE;
  static constexpr Type VIDEO =
    FriendMsg_Type_VIDEO;
  static constexpr Type FILE =
    FriendMsg_Type_FILE;
  static constexpr Type CACELED =
    FriendMsg_Type_CACELED;
  static inline bool Type_IsValid(int value) {
    return FriendMsg_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    FriendMsg_Type_Type_MIN;
  static constexpr Type Type_MAX =
    FriendMsg_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    FriendMsg_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return FriendMsg_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return FriendMsg_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return FriendMsg_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.FriendMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SystemNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SystemNotify) */ {
 public:
  inline SystemNotify() : SystemNotify(nullptr) {}
  ~SystemNotify() override;
  explicit PROTOBUF_CONSTEXPR SystemNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemNotify(const SystemNotify& from);
  SystemNotify(SystemNotify&& from) noexcept
    : SystemNotify() {
    *this = ::std::move(from);
  }

  inline SystemNotify& operator=(const SystemNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemNotify& operator=(SystemNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemNotify* internal_default_instance() {
    return reinterpret_cast<const SystemNotify*>(
               &_SystemNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SystemNotify& a, SystemNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemNotify& from) {
    SystemNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SystemNotify";
  }
  protected:
  explicit SystemNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SystemNotify_Type Type;
  static constexpr Type USER =
    SystemNotify_Type_USER;
  static constexpr Type FRIEND =
    SystemNotify_Type_FRIEND;
  static constexpr Type GROUP =
    SystemNotify_Type_GROUP;
  static inline bool Type_IsValid(int value) {
    return SystemNotify_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    SystemNotify_Type_Type_MIN;
  static constexpr Type Type_MAX =
    SystemNotify_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    SystemNotify_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return SystemNotify_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return SystemNotify_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return SystemNotify_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 3,
  };
  // bytes content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:msg.SystemNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GroupCtrl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GroupCtrl) */ {
 public:
  inline GroupCtrl() : GroupCtrl(nullptr) {}
  ~GroupCtrl() override;
  explicit PROTOBUF_CONSTEXPR GroupCtrl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupCtrl(const GroupCtrl& from);
  GroupCtrl(GroupCtrl&& from) noexcept
    : GroupCtrl() {
    *this = ::std::move(from);
  }

  inline GroupCtrl& operator=(const GroupCtrl& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupCtrl& operator=(GroupCtrl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupCtrl& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupCtrl* internal_default_instance() {
    return reinterpret_cast<const GroupCtrl*>(
               &_GroupCtrl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GroupCtrl& a, GroupCtrl& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupCtrl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupCtrl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupCtrl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupCtrl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupCtrl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupCtrl& from) {
    GroupCtrl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupCtrl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GroupCtrl";
  }
  protected:
  explicit GroupCtrl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GroupCtrl_Type Type;
  static constexpr Type GROUP_CREATE =
    GroupCtrl_Type_GROUP_CREATE;
  static constexpr Type GROUP_DELETE =
    GroupCtrl_Type_GROUP_DELETE;
  static constexpr Type GROUP_ADD_MEMBER =
    GroupCtrl_Type_GROUP_ADD_MEMBER;
  static constexpr Type GROUP_ENTER =
    GroupCtrl_Type_GROUP_ENTER;
  static constexpr Type GROUP_EXIT =
    GroupCtrl_Type_GROUP_EXIT;
  static constexpr Type GROUP_AUTH_OK =
    GroupCtrl_Type_GROUP_AUTH_OK;
  static constexpr Type GROUP_AUTH_REJECT =
    GroupCtrl_Type_GROUP_AUTH_REJECT;
  static inline bool Type_IsValid(int value) {
    return GroupCtrl_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    GroupCtrl_Type_Type_MIN;
  static constexpr Type Type_MAX =
    GroupCtrl_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    GroupCtrl_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return GroupCtrl_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return GroupCtrl_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return GroupCtrl_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // bytes content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // int32 type = 2;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GroupCtrl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class GroupMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.GroupMsg) */ {
 public:
  inline GroupMsg() : GroupMsg(nullptr) {}
  ~GroupMsg() override;
  explicit PROTOBUF_CONSTEXPR GroupMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupMsg(const GroupMsg& from);
  GroupMsg(GroupMsg&& from) noexcept
    : GroupMsg() {
    *this = ::std::move(from);
  }

  inline GroupMsg& operator=(const GroupMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupMsg& operator=(GroupMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupMsg* internal_default_instance() {
    return reinterpret_cast<const GroupMsg*>(
               &_GroupMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GroupMsg& a, GroupMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupMsg& from) {
    GroupMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.GroupMsg";
  }
  protected:
  explicit GroupMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GroupMsg_Type Type;
  static constexpr Type CANCEL =
    GroupMsg_Type_CANCEL;
  static constexpr Type TEXT =
    GroupMsg_Type_TEXT;
  static constexpr Type PICTURE =
    GroupMsg_Type_PICTURE;
  static constexpr Type VIDEO =
    GroupMsg_Type_VIDEO;
  static constexpr Type FILE =
    GroupMsg_Type_FILE;
  static constexpr Type CACELED =
    GroupMsg_Type_CACELED;
  static inline bool Type_IsValid(int value) {
    return GroupMsg_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    GroupMsg_Type_Type_MIN;
  static constexpr Type Type_MAX =
    GroupMsg_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    GroupMsg_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return GroupMsg_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return GroupMsg_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return GroupMsg_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // bytes content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // int32 type = 2;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.GroupMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class Pull final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.Pull) */ {
 public:
  inline Pull() : Pull(nullptr) {}
  ~Pull() override;
  explicit PROTOBUF_CONSTEXPR Pull(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pull(const Pull& from);
  Pull(Pull&& from) noexcept
    : Pull() {
    *this = ::std::move(from);
  }

  inline Pull& operator=(const Pull& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pull& operator=(Pull&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pull& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pull* internal_default_instance() {
    return reinterpret_cast<const Pull*>(
               &_Pull_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Pull& a, Pull& b) {
    a.Swap(&b);
  }
  inline void Swap(Pull* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pull* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pull* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pull>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pull& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pull& from) {
    Pull::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pull* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.Pull";
  }
  protected:
  explicit Pull(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Pull_Type Type;
  static constexpr Type PULL_OFFLINE =
    Pull_Type_PULL_OFFLINE;
  static constexpr Type PULL_HISTORY =
    Pull_Type_PULL_HISTORY;
  static inline bool Type_IsValid(int value) {
    return Pull_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Pull_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Pull_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Pull_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Pull_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Pull_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Pull_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocalSeqFieldNumber = 1,
    kSyncTimeFieldNumber = 2,
    kTypeFieldNumber = 3,
    kLimitFieldNumber = 4,
  };
  // uint64 local_seq = 1;
  void clear_local_seq();
  uint64_t local_seq() const;
  void set_local_seq(uint64_t value);
  private:
  uint64_t _internal_local_seq() const;
  void _internal_set_local_seq(uint64_t value);
  public:

  // int64 sync_time = 2;
  void clear_sync_time();
  int64_t sync_time() const;
  void set_sync_time(int64_t value);
  private:
  int64_t _internal_sync_time() const;
  void _internal_set_sync_time(int64_t value);
  public:

  // int32 type = 3;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // uint32 limit = 4;
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.Pull)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t local_seq_;
    int64_t sync_time_;
    int32_t type_;
    uint32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  explicit PROTOBUF_CONSTEXPR Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Log& from) {
    Log::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Log_Type Type;
  static constexpr Type LOGIN =
    Log_Type_LOGIN;
  static constexpr Type LOGOUT =
    Log_Type_LOGOUT;
  static constexpr Type KICKOUT =
    Log_Type_KICKOUT;
  static inline bool Type_IsValid(int value) {
    return Log_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Log_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Log_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Log_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Log_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Log_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Log_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kContentFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string token = 2;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // bytes content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ProtoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ProtoReq) */ {
 public:
  inline ProtoReq() : ProtoReq(nullptr) {}
  ~ProtoReq() override;
  explicit PROTOBUF_CONSTEXPR ProtoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoReq(const ProtoReq& from);
  ProtoReq(ProtoReq&& from) noexcept
    : ProtoReq() {
    *this = ::std::move(from);
  }

  inline ProtoReq& operator=(const ProtoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoReq& operator=(ProtoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoReq& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kFctrl = 11,
    kFstate = 12,
    kFmsg = 13,
    kNotify = 14,
    kGctrl = 15,
    kGmsg = 16,
    kPull = 17,
    kLog = 18,
    DATA_NOT_SET = 0,
  };

  static inline const ProtoReq* internal_default_instance() {
    return reinterpret_cast<const ProtoReq*>(
               &_ProtoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProtoReq& a, ProtoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoReq& from) {
    ProtoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ProtoReq";
  }
  protected:
  explicit ProtoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProtoReq_Version Version;
  static constexpr Version VERSION_0 =
    ProtoReq_Version_VERSION_0;
  static inline bool Version_IsValid(int value) {
    return ProtoReq_Version_IsValid(value);
  }
  static constexpr Version Version_MIN =
    ProtoReq_Version_Version_MIN;
  static constexpr Version Version_MAX =
    ProtoReq_Version_Version_MAX;
  static constexpr int Version_ARRAYSIZE =
    ProtoReq_Version_Version_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Version_descriptor() {
    return ProtoReq_Version_descriptor();
  }
  template<typename T>
  static inline const std::string& Version_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Version>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Version_Name.");
    return ProtoReq_Version_Name(enum_t_value);
  }
  static inline bool Version_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Version* value) {
    return ProtoReq_Version_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kVersionFieldNumber = 2,
    kFromUidFieldNumber = 3,
    kToIdFieldNumber = 4,
    kFctrlFieldNumber = 11,
    kFstateFieldNumber = 12,
    kFmsgFieldNumber = 13,
    kNotifyFieldNumber = 14,
    kGctrlFieldNumber = 15,
    kGmsgFieldNumber = 16,
    kPullFieldNumber = 17,
    kLogFieldNumber = 18,
  };
  // .msg.ProtoReqType type = 1;
  void clear_type();
  ::msg::ProtoReqType type() const;
  void set_type(::msg::ProtoReqType value);
  private:
  ::msg::ProtoReqType _internal_type() const;
  void _internal_set_type(::msg::ProtoReqType value);
  public:

  // uint32 version = 2;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // uint64 from_uid = 3;
  void clear_from_uid();
  uint64_t from_uid() const;
  void set_from_uid(uint64_t value);
  private:
  uint64_t _internal_from_uid() const;
  void _internal_set_from_uid(uint64_t value);
  public:

  // uint64 to_id = 4;
  void clear_to_id();
  uint64_t to_id() const;
  void set_to_id(uint64_t value);
  private:
  uint64_t _internal_to_id() const;
  void _internal_set_to_id(uint64_t value);
  public:

  // .msg.FriendCtrl fctrl = 11;
  bool has_fctrl() const;
  private:
  bool _internal_has_fctrl() const;
  public:
  void clear_fctrl();
  const ::msg::FriendCtrl& fctrl() const;
  PROTOBUF_NODISCARD ::msg::FriendCtrl* release_fctrl();
  ::msg::FriendCtrl* mutable_fctrl();
  void set_allocated_fctrl(::msg::FriendCtrl* fctrl);
  private:
  const ::msg::FriendCtrl& _internal_fctrl() const;
  ::msg::FriendCtrl* _internal_mutable_fctrl();
  public:
  void unsafe_arena_set_allocated_fctrl(
      ::msg::FriendCtrl* fctrl);
  ::msg::FriendCtrl* unsafe_arena_release_fctrl();

  // .msg.FriendState fstate = 12;
  bool has_fstate() const;
  private:
  bool _internal_has_fstate() const;
  public:
  void clear_fstate();
  const ::msg::FriendState& fstate() const;
  PROTOBUF_NODISCARD ::msg::FriendState* release_fstate();
  ::msg::FriendState* mutable_fstate();
  void set_allocated_fstate(::msg::FriendState* fstate);
  private:
  const ::msg::FriendState& _internal_fstate() const;
  ::msg::FriendState* _internal_mutable_fstate();
  public:
  void unsafe_arena_set_allocated_fstate(
      ::msg::FriendState* fstate);
  ::msg::FriendState* unsafe_arena_release_fstate();

  // .msg.FriendMsg fmsg = 13;
  bool has_fmsg() const;
  private:
  bool _internal_has_fmsg() const;
  public:
  void clear_fmsg();
  const ::msg::FriendMsg& fmsg() const;
  PROTOBUF_NODISCARD ::msg::FriendMsg* release_fmsg();
  ::msg::FriendMsg* mutable_fmsg();
  void set_allocated_fmsg(::msg::FriendMsg* fmsg);
  private:
  const ::msg::FriendMsg& _internal_fmsg() const;
  ::msg::FriendMsg* _internal_mutable_fmsg();
  public:
  void unsafe_arena_set_allocated_fmsg(
      ::msg::FriendMsg* fmsg);
  ::msg::FriendMsg* unsafe_arena_release_fmsg();

  // .msg.SystemNotify notify = 14;
  bool has_notify() const;
  private:
  bool _internal_has_notify() const;
  public:
  void clear_notify();
  const ::msg::SystemNotify& notify() const;
  PROTOBUF_NODISCARD ::msg::SystemNotify* release_notify();
  ::msg::SystemNotify* mutable_notify();
  void set_allocated_notify(::msg::SystemNotify* notify);
  private:
  const ::msg::SystemNotify& _internal_notify() const;
  ::msg::SystemNotify* _internal_mutable_notify();
  public:
  void unsafe_arena_set_allocated_notify(
      ::msg::SystemNotify* notify);
  ::msg::SystemNotify* unsafe_arena_release_notify();

  // .msg.GroupCtrl gctrl = 15;
  bool has_gctrl() const;
  private:
  bool _internal_has_gctrl() const;
  public:
  void clear_gctrl();
  const ::msg::GroupCtrl& gctrl() const;
  PROTOBUF_NODISCARD ::msg::GroupCtrl* release_gctrl();
  ::msg::GroupCtrl* mutable_gctrl();
  void set_allocated_gctrl(::msg::GroupCtrl* gctrl);
  private:
  const ::msg::GroupCtrl& _internal_gctrl() const;
  ::msg::GroupCtrl* _internal_mutable_gctrl();
  public:
  void unsafe_arena_set_allocated_gctrl(
      ::msg::GroupCtrl* gctrl);
  ::msg::GroupCtrl* unsafe_arena_release_gctrl();

  // .msg.GroupMsg gmsg = 16;
  bool has_gmsg() const;
  private:
  bool _internal_has_gmsg() const;
  public:
  void clear_gmsg();
  const ::msg::GroupMsg& gmsg() const;
  PROTOBUF_NODISCARD ::msg::GroupMsg* release_gmsg();
  ::msg::GroupMsg* mutable_gmsg();
  void set_allocated_gmsg(::msg::GroupMsg* gmsg);
  private:
  const ::msg::GroupMsg& _internal_gmsg() const;
  ::msg::GroupMsg* _internal_mutable_gmsg();
  public:
  void unsafe_arena_set_allocated_gmsg(
      ::msg::GroupMsg* gmsg);
  ::msg::GroupMsg* unsafe_arena_release_gmsg();

  // .msg.Pull pull = 17;
  bool has_pull() const;
  private:
  bool _internal_has_pull() const;
  public:
  void clear_pull();
  const ::msg::Pull& pull() const;
  PROTOBUF_NODISCARD ::msg::Pull* release_pull();
  ::msg::Pull* mutable_pull();
  void set_allocated_pull(::msg::Pull* pull);
  private:
  const ::msg::Pull& _internal_pull() const;
  ::msg::Pull* _internal_mutable_pull();
  public:
  void unsafe_arena_set_allocated_pull(
      ::msg::Pull* pull);
  ::msg::Pull* unsafe_arena_release_pull();

  // .msg.Log log = 18;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const ::msg::Log& log() const;
  PROTOBUF_NODISCARD ::msg::Log* release_log();
  ::msg::Log* mutable_log();
  void set_allocated_log(::msg::Log* log);
  private:
  const ::msg::Log& _internal_log() const;
  ::msg::Log* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::msg::Log* log);
  ::msg::Log* unsafe_arena_release_log();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:msg.ProtoReq)
 private:
  class _Internal;
  void set_has_fctrl();
  void set_has_fstate();
  void set_has_fmsg();
  void set_has_notify();
  void set_has_gctrl();
  void set_has_gmsg();
  void set_has_pull();
  void set_has_log();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    uint32_t version_;
    uint64_t from_uid_;
    uint64_t to_id_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::msg::FriendCtrl* fctrl_;
      ::msg::FriendState* fstate_;
      ::msg::FriendMsg* fmsg_;
      ::msg::SystemNotify* notify_;
      ::msg::GroupCtrl* gctrl_;
      ::msg::GroupMsg* gmsg_;
      ::msg::Pull* pull_;
      ::msg::Log* log_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ProtoResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ProtoResp) */ {
 public:
  inline ProtoResp() : ProtoResp(nullptr) {}
  ~ProtoResp() override;
  explicit PROTOBUF_CONSTEXPR ProtoResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoResp(const ProtoResp& from);
  ProtoResp(ProtoResp&& from) noexcept
    : ProtoResp() {
    *this = ::std::move(from);
  }

  inline ProtoResp& operator=(const ProtoResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoResp& operator=(ProtoResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoResp& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kTimestamp = 1,
    kErrorCode = 2,
    RESULT_NOT_SET = 0,
  };

  enum StrCase {
    kMsgid = 3,
    kErr = 4,
    STR_NOT_SET = 0,
  };

  static inline const ProtoResp* internal_default_instance() {
    return reinterpret_cast<const ProtoResp*>(
               &_ProtoResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ProtoResp& a, ProtoResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoResp& from) {
    ProtoResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ProtoResp";
  }
  protected:
  explicit ProtoResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
    kMsgidFieldNumber = 3,
    kErrFieldNumber = 4,
  };
  // int64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 error_code = 2;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // string msgid = 3;
  bool has_msgid() const;
  private:
  bool _internal_has_msgid() const;
  public:
  void clear_msgid();
  const std::string& msgid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msgid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msgid();
  PROTOBUF_NODISCARD std::string* release_msgid();
  void set_allocated_msgid(std::string* msgid);
  private:
  const std::string& _internal_msgid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msgid(const std::string& value);
  std::string* _internal_mutable_msgid();
  public:

  // string err = 4;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const std::string& err() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err();
  PROTOBUF_NODISCARD std::string* release_err();
  void set_allocated_err(std::string* err);
  private:
  const std::string& _internal_err() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err(const std::string& value);
  std::string* _internal_mutable_err();
  public:

  void clear_result();
  ResultCase result_case() const;
  void clear_str();
  StrCase str_case() const;
  // @@protoc_insertion_point(class_scope:msg.ProtoResp)
 private:
  class _Internal;
  void set_has_timestamp();
  void set_has_error_code();
  void set_has_msgid();
  void set_has_err();

  inline bool has_result() const;
  inline void clear_has_result();

  inline bool has_str() const;
  inline void clear_has_str();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t timestamp_;
      int32_t error_code_;
    } result_;
    union StrUnion {
      constexpr StrUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msgid_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_;
    } str_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class MqMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.MqMessage) */ {
 public:
  inline MqMessage() : MqMessage(nullptr) {}
  ~MqMessage() override;
  explicit PROTOBUF_CONSTEXPR MqMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MqMessage(const MqMessage& from);
  MqMessage(MqMessage&& from) noexcept
    : MqMessage() {
    *this = ::std::move(from);
  }

  inline MqMessage& operator=(const MqMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MqMessage& operator=(MqMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MqMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MqMessage* internal_default_instance() {
    return reinterpret_cast<const MqMessage*>(
               &_MqMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MqMessage& a, MqMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MqMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MqMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MqMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MqMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MqMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MqMessage& from) {
    MqMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MqMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.MqMessage";
  }
  protected:
  explicit MqMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginReqFieldNumber = 1,
    kHandleResultFieldNumber = 2,
  };
  // .msg.ProtoReq origin_req = 1;
  bool has_origin_req() const;
  private:
  bool _internal_has_origin_req() const;
  public:
  void clear_origin_req();
  const ::msg::ProtoReq& origin_req() const;
  PROTOBUF_NODISCARD ::msg::ProtoReq* release_origin_req();
  ::msg::ProtoReq* mutable_origin_req();
  void set_allocated_origin_req(::msg::ProtoReq* origin_req);
  private:
  const ::msg::ProtoReq& _internal_origin_req() const;
  ::msg::ProtoReq* _internal_mutable_origin_req();
  public:
  void unsafe_arena_set_allocated_origin_req(
      ::msg::ProtoReq* origin_req);
  ::msg::ProtoReq* unsafe_arena_release_origin_req();

  // .msg.ProtoResp handle_result = 2;
  bool has_handle_result() const;
  private:
  bool _internal_has_handle_result() const;
  public:
  void clear_handle_result();
  const ::msg::ProtoResp& handle_result() const;
  PROTOBUF_NODISCARD ::msg::ProtoResp* release_handle_result();
  ::msg::ProtoResp* mutable_handle_result();
  void set_allocated_handle_result(::msg::ProtoResp* handle_result);
  private:
  const ::msg::ProtoResp& _internal_handle_result() const;
  ::msg::ProtoResp* _internal_mutable_handle_result();
  public:
  void unsafe_arena_set_allocated_handle_result(
      ::msg::ProtoResp* handle_result);
  ::msg::ProtoResp* unsafe_arena_release_handle_result();

  // @@protoc_insertion_point(class_scope:msg.MqMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::msg::ProtoReq* origin_req_;
    ::msg::ProtoResp* handle_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PushReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.PushReq) */ {
 public:
  inline PushReq() : PushReq(nullptr) {}
  ~PushReq() override;
  explicit PROTOBUF_CONSTEXPR PushReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushReq(const PushReq& from);
  PushReq(PushReq&& from) noexcept
    : PushReq() {
    *this = ::std::move(from);
  }

  inline PushReq& operator=(const PushReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushReq& operator=(PushReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushReq* internal_default_instance() {
    return reinterpret_cast<const PushReq*>(
               &_PushReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PushReq& a, PushReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PushReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushReq& from) {
    PushReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PushReq";
  }
  protected:
  explicit PushReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kSeqFieldNumber = 2,
    kToUidFieldNumber = 3,
  };
  // .msg.MqMessage message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::msg::MqMessage& message() const;
  PROTOBUF_NODISCARD ::msg::MqMessage* release_message();
  ::msg::MqMessage* mutable_message();
  void set_allocated_message(::msg::MqMessage* message);
  private:
  const ::msg::MqMessage& _internal_message() const;
  ::msg::MqMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::msg::MqMessage* message);
  ::msg::MqMessage* unsafe_arena_release_message();

  // int64 seq = 2;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // uint64 to_uid = 3;
  void clear_to_uid();
  uint64_t to_uid() const;
  void set_to_uid(uint64_t value);
  private:
  uint64_t _internal_to_uid() const;
  void _internal_set_to_uid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PushReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::msg::MqMessage* message_;
    int64_t seq_;
    uint64_t to_uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PushResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:msg.PushResp) */ {
 public:
  inline PushResp() : PushResp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PushResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushResp(const PushResp& from);
  PushResp(PushResp&& from) noexcept
    : PushResp() {
    *this = ::std::move(from);
  }

  inline PushResp& operator=(const PushResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushResp& operator=(PushResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushResp* internal_default_instance() {
    return reinterpret_cast<const PushResp*>(
               &_PushResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PushResp& a, PushResp& b) {
    a.Swap(&b);
  }
  inline void Swap(PushResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PushResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PushResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PushResp";
  }
  protected:
  explicit PushResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.PushResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_msg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FriendCtrl

// int32 type = 1;
inline void FriendCtrl::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t FriendCtrl::_internal_type() const {
  return _impl_.type_;
}
inline int32_t FriendCtrl::type() const {
  // @@protoc_insertion_point(field_get:msg.FriendCtrl.type)
  return _internal_type();
}
inline void FriendCtrl::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void FriendCtrl::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.FriendCtrl.type)
}

// bytes content = 2;
inline void FriendCtrl::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& FriendCtrl::content() const {
  // @@protoc_insertion_point(field_get:msg.FriendCtrl.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendCtrl::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.FriendCtrl.content)
}
inline std::string* FriendCtrl::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:msg.FriendCtrl.content)
  return _s;
}
inline const std::string& FriendCtrl::_internal_content() const {
  return _impl_.content_.Get();
}
inline void FriendCtrl::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendCtrl::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendCtrl::release_content() {
  // @@protoc_insertion_point(field_release:msg.FriendCtrl.content)
  return _impl_.content_.Release();
}
inline void FriendCtrl::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.FriendCtrl.content)
}

// -------------------------------------------------------------------

// FriendState

// int32 type = 1;
inline void FriendState::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t FriendState::_internal_type() const {
  return _impl_.type_;
}
inline int32_t FriendState::type() const {
  // @@protoc_insertion_point(field_get:msg.FriendState.type)
  return _internal_type();
}
inline void FriendState::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void FriendState::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.FriendState.type)
}

// int32 states = 2;
inline void FriendState::clear_states() {
  _impl_.states_ = 0;
}
inline int32_t FriendState::_internal_states() const {
  return _impl_.states_;
}
inline int32_t FriendState::states() const {
  // @@protoc_insertion_point(field_get:msg.FriendState.states)
  return _internal_states();
}
inline void FriendState::_internal_set_states(int32_t value) {
  
  _impl_.states_ = value;
}
inline void FriendState::set_states(int32_t value) {
  _internal_set_states(value);
  // @@protoc_insertion_point(field_set:msg.FriendState.states)
}

// -------------------------------------------------------------------

// FriendMsg

// int32 type = 1;
inline void FriendMsg::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t FriendMsg::_internal_type() const {
  return _impl_.type_;
}
inline int32_t FriendMsg::type() const {
  // @@protoc_insertion_point(field_get:msg.FriendMsg.type)
  return _internal_type();
}
inline void FriendMsg::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void FriendMsg::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.FriendMsg.type)
}

// bytes content = 2;
inline void FriendMsg::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& FriendMsg::content() const {
  // @@protoc_insertion_point(field_get:msg.FriendMsg.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendMsg::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.FriendMsg.content)
}
inline std::string* FriendMsg::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:msg.FriendMsg.content)
  return _s;
}
inline const std::string& FriendMsg::_internal_content() const {
  return _impl_.content_.Get();
}
inline void FriendMsg::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendMsg::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendMsg::release_content() {
  // @@protoc_insertion_point(field_release:msg.FriendMsg.content)
  return _impl_.content_.Release();
}
inline void FriendMsg::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.FriendMsg.content)
}

// -------------------------------------------------------------------

// SystemNotify

// bytes content = 3;
inline void SystemNotify::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& SystemNotify::content() const {
  // @@protoc_insertion_point(field_get:msg.SystemNotify.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemNotify::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SystemNotify.content)
}
inline std::string* SystemNotify::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:msg.SystemNotify.content)
  return _s;
}
inline const std::string& SystemNotify::_internal_content() const {
  return _impl_.content_.Get();
}
inline void SystemNotify::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemNotify::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemNotify::release_content() {
  // @@protoc_insertion_point(field_release:msg.SystemNotify.content)
  return _impl_.content_.Release();
}
inline void SystemNotify::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SystemNotify.content)
}

// -------------------------------------------------------------------

// GroupCtrl

// int32 type = 2;
inline void GroupCtrl::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t GroupCtrl::_internal_type() const {
  return _impl_.type_;
}
inline int32_t GroupCtrl::type() const {
  // @@protoc_insertion_point(field_get:msg.GroupCtrl.type)
  return _internal_type();
}
inline void GroupCtrl::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void GroupCtrl::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.GroupCtrl.type)
}

// bytes content = 3;
inline void GroupCtrl::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& GroupCtrl::content() const {
  // @@protoc_insertion_point(field_get:msg.GroupCtrl.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupCtrl::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.GroupCtrl.content)
}
inline std::string* GroupCtrl::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:msg.GroupCtrl.content)
  return _s;
}
inline const std::string& GroupCtrl::_internal_content() const {
  return _impl_.content_.Get();
}
inline void GroupCtrl::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupCtrl::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupCtrl::release_content() {
  // @@protoc_insertion_point(field_release:msg.GroupCtrl.content)
  return _impl_.content_.Release();
}
inline void GroupCtrl::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.GroupCtrl.content)
}

// -------------------------------------------------------------------

// GroupMsg

// int32 type = 2;
inline void GroupMsg::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t GroupMsg::_internal_type() const {
  return _impl_.type_;
}
inline int32_t GroupMsg::type() const {
  // @@protoc_insertion_point(field_get:msg.GroupMsg.type)
  return _internal_type();
}
inline void GroupMsg::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void GroupMsg::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.GroupMsg.type)
}

// bytes content = 3;
inline void GroupMsg::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& GroupMsg::content() const {
  // @@protoc_insertion_point(field_get:msg.GroupMsg.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupMsg::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.GroupMsg.content)
}
inline std::string* GroupMsg::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:msg.GroupMsg.content)
  return _s;
}
inline const std::string& GroupMsg::_internal_content() const {
  return _impl_.content_.Get();
}
inline void GroupMsg::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupMsg::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupMsg::release_content() {
  // @@protoc_insertion_point(field_release:msg.GroupMsg.content)
  return _impl_.content_.Release();
}
inline void GroupMsg::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.GroupMsg.content)
}

// -------------------------------------------------------------------

// Pull

// uint64 local_seq = 1;
inline void Pull::clear_local_seq() {
  _impl_.local_seq_ = uint64_t{0u};
}
inline uint64_t Pull::_internal_local_seq() const {
  return _impl_.local_seq_;
}
inline uint64_t Pull::local_seq() const {
  // @@protoc_insertion_point(field_get:msg.Pull.local_seq)
  return _internal_local_seq();
}
inline void Pull::_internal_set_local_seq(uint64_t value) {
  
  _impl_.local_seq_ = value;
}
inline void Pull::set_local_seq(uint64_t value) {
  _internal_set_local_seq(value);
  // @@protoc_insertion_point(field_set:msg.Pull.local_seq)
}

// int64 sync_time = 2;
inline void Pull::clear_sync_time() {
  _impl_.sync_time_ = int64_t{0};
}
inline int64_t Pull::_internal_sync_time() const {
  return _impl_.sync_time_;
}
inline int64_t Pull::sync_time() const {
  // @@protoc_insertion_point(field_get:msg.Pull.sync_time)
  return _internal_sync_time();
}
inline void Pull::_internal_set_sync_time(int64_t value) {
  
  _impl_.sync_time_ = value;
}
inline void Pull::set_sync_time(int64_t value) {
  _internal_set_sync_time(value);
  // @@protoc_insertion_point(field_set:msg.Pull.sync_time)
}

// int32 type = 3;
inline void Pull::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t Pull::_internal_type() const {
  return _impl_.type_;
}
inline int32_t Pull::type() const {
  // @@protoc_insertion_point(field_get:msg.Pull.type)
  return _internal_type();
}
inline void Pull::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void Pull::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.Pull.type)
}

// uint32 limit = 4;
inline void Pull::clear_limit() {
  _impl_.limit_ = 0u;
}
inline uint32_t Pull::_internal_limit() const {
  return _impl_.limit_;
}
inline uint32_t Pull::limit() const {
  // @@protoc_insertion_point(field_get:msg.Pull.limit)
  return _internal_limit();
}
inline void Pull::_internal_set_limit(uint32_t value) {
  
  _impl_.limit_ = value;
}
inline void Pull::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:msg.Pull.limit)
}

// -------------------------------------------------------------------

// Log

// int32 type = 1;
inline void Log::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t Log::_internal_type() const {
  return _impl_.type_;
}
inline int32_t Log::type() const {
  // @@protoc_insertion_point(field_get:msg.Log.type)
  return _internal_type();
}
inline void Log::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void Log::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.Log.type)
}

// string token = 2;
inline void Log::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& Log::token() const {
  // @@protoc_insertion_point(field_get:msg.Log.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.Log.token)
}
inline std::string* Log::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:msg.Log.token)
  return _s;
}
inline const std::string& Log::_internal_token() const {
  return _impl_.token_.Get();
}
inline void Log::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_token() {
  // @@protoc_insertion_point(field_release:msg.Log.token)
  return _impl_.token_.Release();
}
inline void Log::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.Log.token)
}

// bytes content = 3;
inline void Log::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Log::content() const {
  // @@protoc_insertion_point(field_get:msg.Log.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.Log.content)
}
inline std::string* Log::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:msg.Log.content)
  return _s;
}
inline const std::string& Log::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Log::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_content() {
  // @@protoc_insertion_point(field_release:msg.Log.content)
  return _impl_.content_.Release();
}
inline void Log::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.Log.content)
}

// -------------------------------------------------------------------

// ProtoReq

// .msg.ProtoReqType type = 1;
inline void ProtoReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::msg::ProtoReqType ProtoReq::_internal_type() const {
  return static_cast< ::msg::ProtoReqType >(_impl_.type_);
}
inline ::msg::ProtoReqType ProtoReq::type() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.type)
  return _internal_type();
}
inline void ProtoReq::_internal_set_type(::msg::ProtoReqType value) {
  
  _impl_.type_ = value;
}
inline void ProtoReq::set_type(::msg::ProtoReqType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:msg.ProtoReq.type)
}

// uint32 version = 2;
inline void ProtoReq::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t ProtoReq::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t ProtoReq::version() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.version)
  return _internal_version();
}
inline void ProtoReq::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void ProtoReq::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:msg.ProtoReq.version)
}

// uint64 from_uid = 3;
inline void ProtoReq::clear_from_uid() {
  _impl_.from_uid_ = uint64_t{0u};
}
inline uint64_t ProtoReq::_internal_from_uid() const {
  return _impl_.from_uid_;
}
inline uint64_t ProtoReq::from_uid() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.from_uid)
  return _internal_from_uid();
}
inline void ProtoReq::_internal_set_from_uid(uint64_t value) {
  
  _impl_.from_uid_ = value;
}
inline void ProtoReq::set_from_uid(uint64_t value) {
  _internal_set_from_uid(value);
  // @@protoc_insertion_point(field_set:msg.ProtoReq.from_uid)
}

// uint64 to_id = 4;
inline void ProtoReq::clear_to_id() {
  _impl_.to_id_ = uint64_t{0u};
}
inline uint64_t ProtoReq::_internal_to_id() const {
  return _impl_.to_id_;
}
inline uint64_t ProtoReq::to_id() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.to_id)
  return _internal_to_id();
}
inline void ProtoReq::_internal_set_to_id(uint64_t value) {
  
  _impl_.to_id_ = value;
}
inline void ProtoReq::set_to_id(uint64_t value) {
  _internal_set_to_id(value);
  // @@protoc_insertion_point(field_set:msg.ProtoReq.to_id)
}

// .msg.FriendCtrl fctrl = 11;
inline bool ProtoReq::_internal_has_fctrl() const {
  return data_case() == kFctrl;
}
inline bool ProtoReq::has_fctrl() const {
  return _internal_has_fctrl();
}
inline void ProtoReq::set_has_fctrl() {
  _impl_._oneof_case_[0] = kFctrl;
}
inline void ProtoReq::clear_fctrl() {
  if (_internal_has_fctrl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.fctrl_;
    }
    clear_has_data();
  }
}
inline ::msg::FriendCtrl* ProtoReq::release_fctrl() {
  // @@protoc_insertion_point(field_release:msg.ProtoReq.fctrl)
  if (_internal_has_fctrl()) {
    clear_has_data();
    ::msg::FriendCtrl* temp = _impl_.data_.fctrl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.fctrl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::msg::FriendCtrl& ProtoReq::_internal_fctrl() const {
  return _internal_has_fctrl()
      ? *_impl_.data_.fctrl_
      : reinterpret_cast< ::msg::FriendCtrl&>(::msg::_FriendCtrl_default_instance_);
}
inline const ::msg::FriendCtrl& ProtoReq::fctrl() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.fctrl)
  return _internal_fctrl();
}
inline ::msg::FriendCtrl* ProtoReq::unsafe_arena_release_fctrl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:msg.ProtoReq.fctrl)
  if (_internal_has_fctrl()) {
    clear_has_data();
    ::msg::FriendCtrl* temp = _impl_.data_.fctrl_;
    _impl_.data_.fctrl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtoReq::unsafe_arena_set_allocated_fctrl(::msg::FriendCtrl* fctrl) {
  clear_data();
  if (fctrl) {
    set_has_fctrl();
    _impl_.data_.fctrl_ = fctrl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ProtoReq.fctrl)
}
inline ::msg::FriendCtrl* ProtoReq::_internal_mutable_fctrl() {
  if (!_internal_has_fctrl()) {
    clear_data();
    set_has_fctrl();
    _impl_.data_.fctrl_ = CreateMaybeMessage< ::msg::FriendCtrl >(GetArenaForAllocation());
  }
  return _impl_.data_.fctrl_;
}
inline ::msg::FriendCtrl* ProtoReq::mutable_fctrl() {
  ::msg::FriendCtrl* _msg = _internal_mutable_fctrl();
  // @@protoc_insertion_point(field_mutable:msg.ProtoReq.fctrl)
  return _msg;
}

// .msg.FriendState fstate = 12;
inline bool ProtoReq::_internal_has_fstate() const {
  return data_case() == kFstate;
}
inline bool ProtoReq::has_fstate() const {
  return _internal_has_fstate();
}
inline void ProtoReq::set_has_fstate() {
  _impl_._oneof_case_[0] = kFstate;
}
inline void ProtoReq::clear_fstate() {
  if (_internal_has_fstate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.fstate_;
    }
    clear_has_data();
  }
}
inline ::msg::FriendState* ProtoReq::release_fstate() {
  // @@protoc_insertion_point(field_release:msg.ProtoReq.fstate)
  if (_internal_has_fstate()) {
    clear_has_data();
    ::msg::FriendState* temp = _impl_.data_.fstate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.fstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::msg::FriendState& ProtoReq::_internal_fstate() const {
  return _internal_has_fstate()
      ? *_impl_.data_.fstate_
      : reinterpret_cast< ::msg::FriendState&>(::msg::_FriendState_default_instance_);
}
inline const ::msg::FriendState& ProtoReq::fstate() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.fstate)
  return _internal_fstate();
}
inline ::msg::FriendState* ProtoReq::unsafe_arena_release_fstate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:msg.ProtoReq.fstate)
  if (_internal_has_fstate()) {
    clear_has_data();
    ::msg::FriendState* temp = _impl_.data_.fstate_;
    _impl_.data_.fstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtoReq::unsafe_arena_set_allocated_fstate(::msg::FriendState* fstate) {
  clear_data();
  if (fstate) {
    set_has_fstate();
    _impl_.data_.fstate_ = fstate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ProtoReq.fstate)
}
inline ::msg::FriendState* ProtoReq::_internal_mutable_fstate() {
  if (!_internal_has_fstate()) {
    clear_data();
    set_has_fstate();
    _impl_.data_.fstate_ = CreateMaybeMessage< ::msg::FriendState >(GetArenaForAllocation());
  }
  return _impl_.data_.fstate_;
}
inline ::msg::FriendState* ProtoReq::mutable_fstate() {
  ::msg::FriendState* _msg = _internal_mutable_fstate();
  // @@protoc_insertion_point(field_mutable:msg.ProtoReq.fstate)
  return _msg;
}

// .msg.FriendMsg fmsg = 13;
inline bool ProtoReq::_internal_has_fmsg() const {
  return data_case() == kFmsg;
}
inline bool ProtoReq::has_fmsg() const {
  return _internal_has_fmsg();
}
inline void ProtoReq::set_has_fmsg() {
  _impl_._oneof_case_[0] = kFmsg;
}
inline void ProtoReq::clear_fmsg() {
  if (_internal_has_fmsg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.fmsg_;
    }
    clear_has_data();
  }
}
inline ::msg::FriendMsg* ProtoReq::release_fmsg() {
  // @@protoc_insertion_point(field_release:msg.ProtoReq.fmsg)
  if (_internal_has_fmsg()) {
    clear_has_data();
    ::msg::FriendMsg* temp = _impl_.data_.fmsg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.fmsg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::msg::FriendMsg& ProtoReq::_internal_fmsg() const {
  return _internal_has_fmsg()
      ? *_impl_.data_.fmsg_
      : reinterpret_cast< ::msg::FriendMsg&>(::msg::_FriendMsg_default_instance_);
}
inline const ::msg::FriendMsg& ProtoReq::fmsg() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.fmsg)
  return _internal_fmsg();
}
inline ::msg::FriendMsg* ProtoReq::unsafe_arena_release_fmsg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:msg.ProtoReq.fmsg)
  if (_internal_has_fmsg()) {
    clear_has_data();
    ::msg::FriendMsg* temp = _impl_.data_.fmsg_;
    _impl_.data_.fmsg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtoReq::unsafe_arena_set_allocated_fmsg(::msg::FriendMsg* fmsg) {
  clear_data();
  if (fmsg) {
    set_has_fmsg();
    _impl_.data_.fmsg_ = fmsg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ProtoReq.fmsg)
}
inline ::msg::FriendMsg* ProtoReq::_internal_mutable_fmsg() {
  if (!_internal_has_fmsg()) {
    clear_data();
    set_has_fmsg();
    _impl_.data_.fmsg_ = CreateMaybeMessage< ::msg::FriendMsg >(GetArenaForAllocation());
  }
  return _impl_.data_.fmsg_;
}
inline ::msg::FriendMsg* ProtoReq::mutable_fmsg() {
  ::msg::FriendMsg* _msg = _internal_mutable_fmsg();
  // @@protoc_insertion_point(field_mutable:msg.ProtoReq.fmsg)
  return _msg;
}

// .msg.SystemNotify notify = 14;
inline bool ProtoReq::_internal_has_notify() const {
  return data_case() == kNotify;
}
inline bool ProtoReq::has_notify() const {
  return _internal_has_notify();
}
inline void ProtoReq::set_has_notify() {
  _impl_._oneof_case_[0] = kNotify;
}
inline void ProtoReq::clear_notify() {
  if (_internal_has_notify()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.notify_;
    }
    clear_has_data();
  }
}
inline ::msg::SystemNotify* ProtoReq::release_notify() {
  // @@protoc_insertion_point(field_release:msg.ProtoReq.notify)
  if (_internal_has_notify()) {
    clear_has_data();
    ::msg::SystemNotify* temp = _impl_.data_.notify_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.notify_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::msg::SystemNotify& ProtoReq::_internal_notify() const {
  return _internal_has_notify()
      ? *_impl_.data_.notify_
      : reinterpret_cast< ::msg::SystemNotify&>(::msg::_SystemNotify_default_instance_);
}
inline const ::msg::SystemNotify& ProtoReq::notify() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.notify)
  return _internal_notify();
}
inline ::msg::SystemNotify* ProtoReq::unsafe_arena_release_notify() {
  // @@protoc_insertion_point(field_unsafe_arena_release:msg.ProtoReq.notify)
  if (_internal_has_notify()) {
    clear_has_data();
    ::msg::SystemNotify* temp = _impl_.data_.notify_;
    _impl_.data_.notify_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtoReq::unsafe_arena_set_allocated_notify(::msg::SystemNotify* notify) {
  clear_data();
  if (notify) {
    set_has_notify();
    _impl_.data_.notify_ = notify;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ProtoReq.notify)
}
inline ::msg::SystemNotify* ProtoReq::_internal_mutable_notify() {
  if (!_internal_has_notify()) {
    clear_data();
    set_has_notify();
    _impl_.data_.notify_ = CreateMaybeMessage< ::msg::SystemNotify >(GetArenaForAllocation());
  }
  return _impl_.data_.notify_;
}
inline ::msg::SystemNotify* ProtoReq::mutable_notify() {
  ::msg::SystemNotify* _msg = _internal_mutable_notify();
  // @@protoc_insertion_point(field_mutable:msg.ProtoReq.notify)
  return _msg;
}

// .msg.GroupCtrl gctrl = 15;
inline bool ProtoReq::_internal_has_gctrl() const {
  return data_case() == kGctrl;
}
inline bool ProtoReq::has_gctrl() const {
  return _internal_has_gctrl();
}
inline void ProtoReq::set_has_gctrl() {
  _impl_._oneof_case_[0] = kGctrl;
}
inline void ProtoReq::clear_gctrl() {
  if (_internal_has_gctrl()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.gctrl_;
    }
    clear_has_data();
  }
}
inline ::msg::GroupCtrl* ProtoReq::release_gctrl() {
  // @@protoc_insertion_point(field_release:msg.ProtoReq.gctrl)
  if (_internal_has_gctrl()) {
    clear_has_data();
    ::msg::GroupCtrl* temp = _impl_.data_.gctrl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.gctrl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::msg::GroupCtrl& ProtoReq::_internal_gctrl() const {
  return _internal_has_gctrl()
      ? *_impl_.data_.gctrl_
      : reinterpret_cast< ::msg::GroupCtrl&>(::msg::_GroupCtrl_default_instance_);
}
inline const ::msg::GroupCtrl& ProtoReq::gctrl() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.gctrl)
  return _internal_gctrl();
}
inline ::msg::GroupCtrl* ProtoReq::unsafe_arena_release_gctrl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:msg.ProtoReq.gctrl)
  if (_internal_has_gctrl()) {
    clear_has_data();
    ::msg::GroupCtrl* temp = _impl_.data_.gctrl_;
    _impl_.data_.gctrl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtoReq::unsafe_arena_set_allocated_gctrl(::msg::GroupCtrl* gctrl) {
  clear_data();
  if (gctrl) {
    set_has_gctrl();
    _impl_.data_.gctrl_ = gctrl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ProtoReq.gctrl)
}
inline ::msg::GroupCtrl* ProtoReq::_internal_mutable_gctrl() {
  if (!_internal_has_gctrl()) {
    clear_data();
    set_has_gctrl();
    _impl_.data_.gctrl_ = CreateMaybeMessage< ::msg::GroupCtrl >(GetArenaForAllocation());
  }
  return _impl_.data_.gctrl_;
}
inline ::msg::GroupCtrl* ProtoReq::mutable_gctrl() {
  ::msg::GroupCtrl* _msg = _internal_mutable_gctrl();
  // @@protoc_insertion_point(field_mutable:msg.ProtoReq.gctrl)
  return _msg;
}

// .msg.GroupMsg gmsg = 16;
inline bool ProtoReq::_internal_has_gmsg() const {
  return data_case() == kGmsg;
}
inline bool ProtoReq::has_gmsg() const {
  return _internal_has_gmsg();
}
inline void ProtoReq::set_has_gmsg() {
  _impl_._oneof_case_[0] = kGmsg;
}
inline void ProtoReq::clear_gmsg() {
  if (_internal_has_gmsg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.gmsg_;
    }
    clear_has_data();
  }
}
inline ::msg::GroupMsg* ProtoReq::release_gmsg() {
  // @@protoc_insertion_point(field_release:msg.ProtoReq.gmsg)
  if (_internal_has_gmsg()) {
    clear_has_data();
    ::msg::GroupMsg* temp = _impl_.data_.gmsg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.gmsg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::msg::GroupMsg& ProtoReq::_internal_gmsg() const {
  return _internal_has_gmsg()
      ? *_impl_.data_.gmsg_
      : reinterpret_cast< ::msg::GroupMsg&>(::msg::_GroupMsg_default_instance_);
}
inline const ::msg::GroupMsg& ProtoReq::gmsg() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.gmsg)
  return _internal_gmsg();
}
inline ::msg::GroupMsg* ProtoReq::unsafe_arena_release_gmsg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:msg.ProtoReq.gmsg)
  if (_internal_has_gmsg()) {
    clear_has_data();
    ::msg::GroupMsg* temp = _impl_.data_.gmsg_;
    _impl_.data_.gmsg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtoReq::unsafe_arena_set_allocated_gmsg(::msg::GroupMsg* gmsg) {
  clear_data();
  if (gmsg) {
    set_has_gmsg();
    _impl_.data_.gmsg_ = gmsg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ProtoReq.gmsg)
}
inline ::msg::GroupMsg* ProtoReq::_internal_mutable_gmsg() {
  if (!_internal_has_gmsg()) {
    clear_data();
    set_has_gmsg();
    _impl_.data_.gmsg_ = CreateMaybeMessage< ::msg::GroupMsg >(GetArenaForAllocation());
  }
  return _impl_.data_.gmsg_;
}
inline ::msg::GroupMsg* ProtoReq::mutable_gmsg() {
  ::msg::GroupMsg* _msg = _internal_mutable_gmsg();
  // @@protoc_insertion_point(field_mutable:msg.ProtoReq.gmsg)
  return _msg;
}

// .msg.Pull pull = 17;
inline bool ProtoReq::_internal_has_pull() const {
  return data_case() == kPull;
}
inline bool ProtoReq::has_pull() const {
  return _internal_has_pull();
}
inline void ProtoReq::set_has_pull() {
  _impl_._oneof_case_[0] = kPull;
}
inline void ProtoReq::clear_pull() {
  if (_internal_has_pull()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.pull_;
    }
    clear_has_data();
  }
}
inline ::msg::Pull* ProtoReq::release_pull() {
  // @@protoc_insertion_point(field_release:msg.ProtoReq.pull)
  if (_internal_has_pull()) {
    clear_has_data();
    ::msg::Pull* temp = _impl_.data_.pull_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.pull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::msg::Pull& ProtoReq::_internal_pull() const {
  return _internal_has_pull()
      ? *_impl_.data_.pull_
      : reinterpret_cast< ::msg::Pull&>(::msg::_Pull_default_instance_);
}
inline const ::msg::Pull& ProtoReq::pull() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.pull)
  return _internal_pull();
}
inline ::msg::Pull* ProtoReq::unsafe_arena_release_pull() {
  // @@protoc_insertion_point(field_unsafe_arena_release:msg.ProtoReq.pull)
  if (_internal_has_pull()) {
    clear_has_data();
    ::msg::Pull* temp = _impl_.data_.pull_;
    _impl_.data_.pull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtoReq::unsafe_arena_set_allocated_pull(::msg::Pull* pull) {
  clear_data();
  if (pull) {
    set_has_pull();
    _impl_.data_.pull_ = pull;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ProtoReq.pull)
}
inline ::msg::Pull* ProtoReq::_internal_mutable_pull() {
  if (!_internal_has_pull()) {
    clear_data();
    set_has_pull();
    _impl_.data_.pull_ = CreateMaybeMessage< ::msg::Pull >(GetArenaForAllocation());
  }
  return _impl_.data_.pull_;
}
inline ::msg::Pull* ProtoReq::mutable_pull() {
  ::msg::Pull* _msg = _internal_mutable_pull();
  // @@protoc_insertion_point(field_mutable:msg.ProtoReq.pull)
  return _msg;
}

// .msg.Log log = 18;
inline bool ProtoReq::_internal_has_log() const {
  return data_case() == kLog;
}
inline bool ProtoReq::has_log() const {
  return _internal_has_log();
}
inline void ProtoReq::set_has_log() {
  _impl_._oneof_case_[0] = kLog;
}
inline void ProtoReq::clear_log() {
  if (_internal_has_log()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.log_;
    }
    clear_has_data();
  }
}
inline ::msg::Log* ProtoReq::release_log() {
  // @@protoc_insertion_point(field_release:msg.ProtoReq.log)
  if (_internal_has_log()) {
    clear_has_data();
    ::msg::Log* temp = _impl_.data_.log_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::msg::Log& ProtoReq::_internal_log() const {
  return _internal_has_log()
      ? *_impl_.data_.log_
      : reinterpret_cast< ::msg::Log&>(::msg::_Log_default_instance_);
}
inline const ::msg::Log& ProtoReq::log() const {
  // @@protoc_insertion_point(field_get:msg.ProtoReq.log)
  return _internal_log();
}
inline ::msg::Log* ProtoReq::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:msg.ProtoReq.log)
  if (_internal_has_log()) {
    clear_has_data();
    ::msg::Log* temp = _impl_.data_.log_;
    _impl_.data_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtoReq::unsafe_arena_set_allocated_log(::msg::Log* log) {
  clear_data();
  if (log) {
    set_has_log();
    _impl_.data_.log_ = log;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.ProtoReq.log)
}
inline ::msg::Log* ProtoReq::_internal_mutable_log() {
  if (!_internal_has_log()) {
    clear_data();
    set_has_log();
    _impl_.data_.log_ = CreateMaybeMessage< ::msg::Log >(GetArenaForAllocation());
  }
  return _impl_.data_.log_;
}
inline ::msg::Log* ProtoReq::mutable_log() {
  ::msg::Log* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:msg.ProtoReq.log)
  return _msg;
}

inline bool ProtoReq::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void ProtoReq::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline ProtoReq::DataCase ProtoReq::data_case() const {
  return ProtoReq::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProtoResp

// int64 timestamp = 1;
inline bool ProtoResp::_internal_has_timestamp() const {
  return result_case() == kTimestamp;
}
inline bool ProtoResp::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ProtoResp::set_has_timestamp() {
  _impl_._oneof_case_[0] = kTimestamp;
}
inline void ProtoResp::clear_timestamp() {
  if (_internal_has_timestamp()) {
    _impl_.result_.timestamp_ = int64_t{0};
    clear_has_result();
  }
}
inline int64_t ProtoResp::_internal_timestamp() const {
  if (_internal_has_timestamp()) {
    return _impl_.result_.timestamp_;
  }
  return int64_t{0};
}
inline void ProtoResp::_internal_set_timestamp(int64_t value) {
  if (!_internal_has_timestamp()) {
    clear_result();
    set_has_timestamp();
  }
  _impl_.result_.timestamp_ = value;
}
inline int64_t ProtoResp::timestamp() const {
  // @@protoc_insertion_point(field_get:msg.ProtoResp.timestamp)
  return _internal_timestamp();
}
inline void ProtoResp::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:msg.ProtoResp.timestamp)
}

// int32 error_code = 2;
inline bool ProtoResp::_internal_has_error_code() const {
  return result_case() == kErrorCode;
}
inline bool ProtoResp::has_error_code() const {
  return _internal_has_error_code();
}
inline void ProtoResp::set_has_error_code() {
  _impl_._oneof_case_[0] = kErrorCode;
}
inline void ProtoResp::clear_error_code() {
  if (_internal_has_error_code()) {
    _impl_.result_.error_code_ = 0;
    clear_has_result();
  }
}
inline int32_t ProtoResp::_internal_error_code() const {
  if (_internal_has_error_code()) {
    return _impl_.result_.error_code_;
  }
  return 0;
}
inline void ProtoResp::_internal_set_error_code(int32_t value) {
  if (!_internal_has_error_code()) {
    clear_result();
    set_has_error_code();
  }
  _impl_.result_.error_code_ = value;
}
inline int32_t ProtoResp::error_code() const {
  // @@protoc_insertion_point(field_get:msg.ProtoResp.error_code)
  return _internal_error_code();
}
inline void ProtoResp::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:msg.ProtoResp.error_code)
}

// string msgid = 3;
inline bool ProtoResp::_internal_has_msgid() const {
  return str_case() == kMsgid;
}
inline bool ProtoResp::has_msgid() const {
  return _internal_has_msgid();
}
inline void ProtoResp::set_has_msgid() {
  _impl_._oneof_case_[1] = kMsgid;
}
inline void ProtoResp::clear_msgid() {
  if (_internal_has_msgid()) {
    _impl_.str_.msgid_.Destroy();
    clear_has_str();
  }
}
inline const std::string& ProtoResp::msgid() const {
  // @@protoc_insertion_point(field_get:msg.ProtoResp.msgid)
  return _internal_msgid();
}
template <typename ArgT0, typename... ArgT>
inline void ProtoResp::set_msgid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_msgid()) {
    clear_str();
    set_has_msgid();
    _impl_.str_.msgid_.InitDefault();
  }
  _impl_.str_.msgid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ProtoResp.msgid)
}
inline std::string* ProtoResp::mutable_msgid() {
  std::string* _s = _internal_mutable_msgid();
  // @@protoc_insertion_point(field_mutable:msg.ProtoResp.msgid)
  return _s;
}
inline const std::string& ProtoResp::_internal_msgid() const {
  if (_internal_has_msgid()) {
    return _impl_.str_.msgid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ProtoResp::_internal_set_msgid(const std::string& value) {
  if (!_internal_has_msgid()) {
    clear_str();
    set_has_msgid();
    _impl_.str_.msgid_.InitDefault();
  }
  _impl_.str_.msgid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoResp::_internal_mutable_msgid() {
  if (!_internal_has_msgid()) {
    clear_str();
    set_has_msgid();
    _impl_.str_.msgid_.InitDefault();
  }
  return _impl_.str_.msgid_.Mutable(      GetArenaForAllocation());
}
inline std::string* ProtoResp::release_msgid() {
  // @@protoc_insertion_point(field_release:msg.ProtoResp.msgid)
  if (_internal_has_msgid()) {
    clear_has_str();
    return _impl_.str_.msgid_.Release();
  } else {
    return nullptr;
  }
}
inline void ProtoResp::set_allocated_msgid(std::string* msgid) {
  if (has_str()) {
    clear_str();
  }
  if (msgid != nullptr) {
    set_has_msgid();
    _impl_.str_.msgid_.InitAllocated(msgid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.ProtoResp.msgid)
}

// string err = 4;
inline bool ProtoResp::_internal_has_err() const {
  return str_case() == kErr;
}
inline bool ProtoResp::has_err() const {
  return _internal_has_err();
}
inline void ProtoResp::set_has_err() {
  _impl_._oneof_case_[1] = kErr;
}
inline void ProtoResp::clear_err() {
  if (_internal_has_err()) {
    _impl_.str_.err_.Destroy();
    clear_has_str();
  }
}
inline const std::string& ProtoResp::err() const {
  // @@protoc_insertion_point(field_get:msg.ProtoResp.err)
  return _internal_err();
}
template <typename ArgT0, typename... ArgT>
inline void ProtoResp::set_err(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_err()) {
    clear_str();
    set_has_err();
    _impl_.str_.err_.InitDefault();
  }
  _impl_.str_.err_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ProtoResp.err)
}
inline std::string* ProtoResp::mutable_err() {
  std::string* _s = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:msg.ProtoResp.err)
  return _s;
}
inline const std::string& ProtoResp::_internal_err() const {
  if (_internal_has_err()) {
    return _impl_.str_.err_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ProtoResp::_internal_set_err(const std::string& value) {
  if (!_internal_has_err()) {
    clear_str();
    set_has_err();
    _impl_.str_.err_.InitDefault();
  }
  _impl_.str_.err_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoResp::_internal_mutable_err() {
  if (!_internal_has_err()) {
    clear_str();
    set_has_err();
    _impl_.str_.err_.InitDefault();
  }
  return _impl_.str_.err_.Mutable(      GetArenaForAllocation());
}
inline std::string* ProtoResp::release_err() {
  // @@protoc_insertion_point(field_release:msg.ProtoResp.err)
  if (_internal_has_err()) {
    clear_has_str();
    return _impl_.str_.err_.Release();
  } else {
    return nullptr;
  }
}
inline void ProtoResp::set_allocated_err(std::string* err) {
  if (has_str()) {
    clear_str();
  }
  if (err != nullptr) {
    set_has_err();
    _impl_.str_.err_.InitAllocated(err, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:msg.ProtoResp.err)
}

inline bool ProtoResp::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void ProtoResp::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline bool ProtoResp::has_str() const {
  return str_case() != STR_NOT_SET;
}
inline void ProtoResp::clear_has_str() {
  _impl_._oneof_case_[1] = STR_NOT_SET;
}
inline ProtoResp::ResultCase ProtoResp::result_case() const {
  return ProtoResp::ResultCase(_impl_._oneof_case_[0]);
}
inline ProtoResp::StrCase ProtoResp::str_case() const {
  return ProtoResp::StrCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// MqMessage

// .msg.ProtoReq origin_req = 1;
inline bool MqMessage::_internal_has_origin_req() const {
  return this != internal_default_instance() && _impl_.origin_req_ != nullptr;
}
inline bool MqMessage::has_origin_req() const {
  return _internal_has_origin_req();
}
inline void MqMessage::clear_origin_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.origin_req_ != nullptr) {
    delete _impl_.origin_req_;
  }
  _impl_.origin_req_ = nullptr;
}
inline const ::msg::ProtoReq& MqMessage::_internal_origin_req() const {
  const ::msg::ProtoReq* p = _impl_.origin_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::msg::ProtoReq&>(
      ::msg::_ProtoReq_default_instance_);
}
inline const ::msg::ProtoReq& MqMessage::origin_req() const {
  // @@protoc_insertion_point(field_get:msg.MqMessage.origin_req)
  return _internal_origin_req();
}
inline void MqMessage::unsafe_arena_set_allocated_origin_req(
    ::msg::ProtoReq* origin_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_req_);
  }
  _impl_.origin_req_ = origin_req;
  if (origin_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.MqMessage.origin_req)
}
inline ::msg::ProtoReq* MqMessage::release_origin_req() {
  
  ::msg::ProtoReq* temp = _impl_.origin_req_;
  _impl_.origin_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::msg::ProtoReq* MqMessage::unsafe_arena_release_origin_req() {
  // @@protoc_insertion_point(field_release:msg.MqMessage.origin_req)
  
  ::msg::ProtoReq* temp = _impl_.origin_req_;
  _impl_.origin_req_ = nullptr;
  return temp;
}
inline ::msg::ProtoReq* MqMessage::_internal_mutable_origin_req() {
  
  if (_impl_.origin_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::ProtoReq>(GetArenaForAllocation());
    _impl_.origin_req_ = p;
  }
  return _impl_.origin_req_;
}
inline ::msg::ProtoReq* MqMessage::mutable_origin_req() {
  ::msg::ProtoReq* _msg = _internal_mutable_origin_req();
  // @@protoc_insertion_point(field_mutable:msg.MqMessage.origin_req)
  return _msg;
}
inline void MqMessage::set_allocated_origin_req(::msg::ProtoReq* origin_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.origin_req_;
  }
  if (origin_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(origin_req);
    if (message_arena != submessage_arena) {
      origin_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.origin_req_ = origin_req;
  // @@protoc_insertion_point(field_set_allocated:msg.MqMessage.origin_req)
}

// .msg.ProtoResp handle_result = 2;
inline bool MqMessage::_internal_has_handle_result() const {
  return this != internal_default_instance() && _impl_.handle_result_ != nullptr;
}
inline bool MqMessage::has_handle_result() const {
  return _internal_has_handle_result();
}
inline void MqMessage::clear_handle_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.handle_result_ != nullptr) {
    delete _impl_.handle_result_;
  }
  _impl_.handle_result_ = nullptr;
}
inline const ::msg::ProtoResp& MqMessage::_internal_handle_result() const {
  const ::msg::ProtoResp* p = _impl_.handle_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::msg::ProtoResp&>(
      ::msg::_ProtoResp_default_instance_);
}
inline const ::msg::ProtoResp& MqMessage::handle_result() const {
  // @@protoc_insertion_point(field_get:msg.MqMessage.handle_result)
  return _internal_handle_result();
}
inline void MqMessage::unsafe_arena_set_allocated_handle_result(
    ::msg::ProtoResp* handle_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_result_);
  }
  _impl_.handle_result_ = handle_result;
  if (handle_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.MqMessage.handle_result)
}
inline ::msg::ProtoResp* MqMessage::release_handle_result() {
  
  ::msg::ProtoResp* temp = _impl_.handle_result_;
  _impl_.handle_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::msg::ProtoResp* MqMessage::unsafe_arena_release_handle_result() {
  // @@protoc_insertion_point(field_release:msg.MqMessage.handle_result)
  
  ::msg::ProtoResp* temp = _impl_.handle_result_;
  _impl_.handle_result_ = nullptr;
  return temp;
}
inline ::msg::ProtoResp* MqMessage::_internal_mutable_handle_result() {
  
  if (_impl_.handle_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::ProtoResp>(GetArenaForAllocation());
    _impl_.handle_result_ = p;
  }
  return _impl_.handle_result_;
}
inline ::msg::ProtoResp* MqMessage::mutable_handle_result() {
  ::msg::ProtoResp* _msg = _internal_mutable_handle_result();
  // @@protoc_insertion_point(field_mutable:msg.MqMessage.handle_result)
  return _msg;
}
inline void MqMessage::set_allocated_handle_result(::msg::ProtoResp* handle_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.handle_result_;
  }
  if (handle_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(handle_result);
    if (message_arena != submessage_arena) {
      handle_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.handle_result_ = handle_result;
  // @@protoc_insertion_point(field_set_allocated:msg.MqMessage.handle_result)
}

// -------------------------------------------------------------------

// PushReq

// .msg.MqMessage message = 1;
inline bool PushReq::_internal_has_message() const {
  return this != internal_default_instance() && _impl_.message_ != nullptr;
}
inline bool PushReq::has_message() const {
  return _internal_has_message();
}
inline void PushReq::clear_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.message_ != nullptr) {
    delete _impl_.message_;
  }
  _impl_.message_ = nullptr;
}
inline const ::msg::MqMessage& PushReq::_internal_message() const {
  const ::msg::MqMessage* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::msg::MqMessage&>(
      ::msg::_MqMessage_default_instance_);
}
inline const ::msg::MqMessage& PushReq::message() const {
  // @@protoc_insertion_point(field_get:msg.PushReq.message)
  return _internal_message();
}
inline void PushReq::unsafe_arena_set_allocated_message(
    ::msg::MqMessage* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:msg.PushReq.message)
}
inline ::msg::MqMessage* PushReq::release_message() {
  
  ::msg::MqMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::msg::MqMessage* PushReq::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:msg.PushReq.message)
  
  ::msg::MqMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::msg::MqMessage* PushReq::_internal_mutable_message() {
  
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::MqMessage>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::msg::MqMessage* PushReq::mutable_message() {
  ::msg::MqMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:msg.PushReq.message)
  return _msg;
}
inline void PushReq::set_allocated_message(::msg::MqMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:msg.PushReq.message)
}

// int64 seq = 2;
inline void PushReq::clear_seq() {
  _impl_.seq_ = int64_t{0};
}
inline int64_t PushReq::_internal_seq() const {
  return _impl_.seq_;
}
inline int64_t PushReq::seq() const {
  // @@protoc_insertion_point(field_get:msg.PushReq.seq)
  return _internal_seq();
}
inline void PushReq::_internal_set_seq(int64_t value) {
  
  _impl_.seq_ = value;
}
inline void PushReq::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:msg.PushReq.seq)
}

// uint64 to_uid = 3;
inline void PushReq::clear_to_uid() {
  _impl_.to_uid_ = uint64_t{0u};
}
inline uint64_t PushReq::_internal_to_uid() const {
  return _impl_.to_uid_;
}
inline uint64_t PushReq::to_uid() const {
  // @@protoc_insertion_point(field_get:msg.PushReq.to_uid)
  return _internal_to_uid();
}
inline void PushReq::_internal_set_to_uid(uint64_t value) {
  
  _impl_.to_uid_ = value;
}
inline void PushReq::set_to_uid(uint64_t value) {
  _internal_set_to_uid(value);
  // @@protoc_insertion_point(field_set:msg.PushReq.to_uid)
}

// -------------------------------------------------------------------

// PushResp

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::msg::FriendCtrl_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::FriendCtrl_Type>() {
  return ::msg::FriendCtrl_Type_descriptor();
}
template <> struct is_proto_enum< ::msg::FriendState_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::FriendState_Type>() {
  return ::msg::FriendState_Type_descriptor();
}
template <> struct is_proto_enum< ::msg::FriendMsg_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::FriendMsg_Type>() {
  return ::msg::FriendMsg_Type_descriptor();
}
template <> struct is_proto_enum< ::msg::SystemNotify_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::SystemNotify_Type>() {
  return ::msg::SystemNotify_Type_descriptor();
}
template <> struct is_proto_enum< ::msg::GroupCtrl_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::GroupCtrl_Type>() {
  return ::msg::GroupCtrl_Type_descriptor();
}
template <> struct is_proto_enum< ::msg::GroupMsg_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::GroupMsg_Type>() {
  return ::msg::GroupMsg_Type_descriptor();
}
template <> struct is_proto_enum< ::msg::Pull_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::Pull_Type>() {
  return ::msg::Pull_Type_descriptor();
}
template <> struct is_proto_enum< ::msg::Log_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::Log_Type>() {
  return ::msg::Log_Type_descriptor();
}
template <> struct is_proto_enum< ::msg::ProtoReq_Version> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::ProtoReq_Version>() {
  return ::msg::ProtoReq_Version_descriptor();
}
template <> struct is_proto_enum< ::msg::ProtoReqType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::ProtoReqType>() {
  return ::msg::ProtoReqType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
