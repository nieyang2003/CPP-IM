// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: route.proto

#include "route.pb.h"
#include "route.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace route {

static const char* RouteService_method_names[] = {
  "/route.RouteService/Login",
  "/route.RouteService/DispatchMsgServer",
  "/route.RouteService/MsgServerHeartBeat",
  "/route.RouteService/GetMsgServer",
};

std::unique_ptr< RouteService::Stub> RouteService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< RouteService::Stub> stub(new RouteService::Stub(channel, options));
  return stub;
}

RouteService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Login_(RouteService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DispatchMsgServer_(RouteService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MsgServerHeartBeat_(RouteService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetMsgServer_(RouteService_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status RouteService::Stub::Login(::grpc::ClientContext* context, const ::route::LoginRequest& request, ::route::LoginResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::route::LoginRequest, ::route::LoginResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Login_, context, request, response);
}

void RouteService::Stub::async::Login(::grpc::ClientContext* context, const ::route::LoginRequest* request, ::route::LoginResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::route::LoginRequest, ::route::LoginResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Login_, context, request, response, std::move(f));
}

void RouteService::Stub::async::Login(::grpc::ClientContext* context, const ::route::LoginRequest* request, ::route::LoginResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Login_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::route::LoginResponse>* RouteService::Stub::PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::route::LoginRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::route::LoginResponse, ::route::LoginRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Login_, context, request);
}

::grpc::ClientAsyncResponseReader< ::route::LoginResponse>* RouteService::Stub::AsyncLoginRaw(::grpc::ClientContext* context, const ::route::LoginRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncLoginRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RouteService::Stub::DispatchMsgServer(::grpc::ClientContext* context, const ::route::DispatchMsgServerRequest& request, ::route::DispatchMsgServerResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::route::DispatchMsgServerRequest, ::route::DispatchMsgServerResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_DispatchMsgServer_, context, request, response);
}

void RouteService::Stub::async::DispatchMsgServer(::grpc::ClientContext* context, const ::route::DispatchMsgServerRequest* request, ::route::DispatchMsgServerResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::route::DispatchMsgServerRequest, ::route::DispatchMsgServerResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_DispatchMsgServer_, context, request, response, std::move(f));
}

void RouteService::Stub::async::DispatchMsgServer(::grpc::ClientContext* context, const ::route::DispatchMsgServerRequest* request, ::route::DispatchMsgServerResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_DispatchMsgServer_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::route::DispatchMsgServerResponse>* RouteService::Stub::PrepareAsyncDispatchMsgServerRaw(::grpc::ClientContext* context, const ::route::DispatchMsgServerRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::route::DispatchMsgServerResponse, ::route::DispatchMsgServerRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_DispatchMsgServer_, context, request);
}

::grpc::ClientAsyncResponseReader< ::route::DispatchMsgServerResponse>* RouteService::Stub::AsyncDispatchMsgServerRaw(::grpc::ClientContext* context, const ::route::DispatchMsgServerRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncDispatchMsgServerRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RouteService::Stub::MsgServerHeartBeat(::grpc::ClientContext* context, const ::route::HeartBeatRequest& request, ::route::HeartBeatResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::route::HeartBeatRequest, ::route::HeartBeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MsgServerHeartBeat_, context, request, response);
}

void RouteService::Stub::async::MsgServerHeartBeat(::grpc::ClientContext* context, const ::route::HeartBeatRequest* request, ::route::HeartBeatResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::route::HeartBeatRequest, ::route::HeartBeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MsgServerHeartBeat_, context, request, response, std::move(f));
}

void RouteService::Stub::async::MsgServerHeartBeat(::grpc::ClientContext* context, const ::route::HeartBeatRequest* request, ::route::HeartBeatResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MsgServerHeartBeat_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::route::HeartBeatResponse>* RouteService::Stub::PrepareAsyncMsgServerHeartBeatRaw(::grpc::ClientContext* context, const ::route::HeartBeatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::route::HeartBeatResponse, ::route::HeartBeatRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MsgServerHeartBeat_, context, request);
}

::grpc::ClientAsyncResponseReader< ::route::HeartBeatResponse>* RouteService::Stub::AsyncMsgServerHeartBeatRaw(::grpc::ClientContext* context, const ::route::HeartBeatRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMsgServerHeartBeatRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RouteService::Stub::GetMsgServer(::grpc::ClientContext* context, const ::route::GetMsgServerRequest& request, ::route::GetMsgServerResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::route::GetMsgServerRequest, ::route::GetMsgServerResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetMsgServer_, context, request, response);
}

void RouteService::Stub::async::GetMsgServer(::grpc::ClientContext* context, const ::route::GetMsgServerRequest* request, ::route::GetMsgServerResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::route::GetMsgServerRequest, ::route::GetMsgServerResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetMsgServer_, context, request, response, std::move(f));
}

void RouteService::Stub::async::GetMsgServer(::grpc::ClientContext* context, const ::route::GetMsgServerRequest* request, ::route::GetMsgServerResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetMsgServer_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::route::GetMsgServerResponse>* RouteService::Stub::PrepareAsyncGetMsgServerRaw(::grpc::ClientContext* context, const ::route::GetMsgServerRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::route::GetMsgServerResponse, ::route::GetMsgServerRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetMsgServer_, context, request);
}

::grpc::ClientAsyncResponseReader< ::route::GetMsgServerResponse>* RouteService::Stub::AsyncGetMsgServerRaw(::grpc::ClientContext* context, const ::route::GetMsgServerRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetMsgServerRaw(context, request, cq);
  result->StartCall();
  return result;
}

RouteService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RouteService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RouteService::Service, ::route::LoginRequest, ::route::LoginResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RouteService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::route::LoginRequest* req,
             ::route::LoginResponse* resp) {
               return service->Login(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RouteService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RouteService::Service, ::route::DispatchMsgServerRequest, ::route::DispatchMsgServerResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RouteService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::route::DispatchMsgServerRequest* req,
             ::route::DispatchMsgServerResponse* resp) {
               return service->DispatchMsgServer(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RouteService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RouteService::Service, ::route::HeartBeatRequest, ::route::HeartBeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RouteService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::route::HeartBeatRequest* req,
             ::route::HeartBeatResponse* resp) {
               return service->MsgServerHeartBeat(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RouteService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RouteService::Service, ::route::GetMsgServerRequest, ::route::GetMsgServerResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RouteService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::route::GetMsgServerRequest* req,
             ::route::GetMsgServerResponse* resp) {
               return service->GetMsgServer(ctx, req, resp);
             }, this)));
}

RouteService::Service::~Service() {
}

::grpc::Status RouteService::Service::Login(::grpc::ServerContext* context, const ::route::LoginRequest* request, ::route::LoginResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RouteService::Service::DispatchMsgServer(::grpc::ServerContext* context, const ::route::DispatchMsgServerRequest* request, ::route::DispatchMsgServerResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RouteService::Service::MsgServerHeartBeat(::grpc::ServerContext* context, const ::route::HeartBeatRequest* request, ::route::HeartBeatResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RouteService::Service::GetMsgServer(::grpc::ServerContext* context, const ::route::GetMsgServerRequest* request, ::route::GetMsgServerResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace route

